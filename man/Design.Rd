% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/r6designclass.R
\name{Design}
\alias{Design}
\title{A GLMM Design}
\description{
A GLMM Design

A GLMM Design
}
\details{
An R6 class representing a GLMM and study design

For the generalised linear mixed model

\deqn{Y \sim F(\mu,\sigma)}
\deqn{\mu = h^-1(X\beta + Z\gamma)}
\deqn{\gamma \sim MVN(0,D)}

where h is the link function. A Design in comprised of a \link[glmmr]{MeanFunction} object, which defines the family F,
link function h, and fixed effects design matrix X, and a \link[glmmr]{Covariance} object, which defines Z and D. The class provides
methods for analysis and simulation with these models.

This class provides methods for: data simulation (\code{sim_data()} and \code{fitted()}), model fitting using Markov Chain
Monte Carlo Maximum Likelihood (MCML) methods (\code{MCML()}), design analysis via simulation including power (\code{analysis()}),
deletion diagnostics (\code{dfbeta()}), and permutation tests including p-values and confidence intervals (\code{permutation()}).

The class by default calculates the covariance matrix of the observations as:

\deqn{\Sigma = W^{-1} + ZDZ^T}

where \emph{W} is a diagonal matrix with the WLS iterated weights for each observation equal
to, for individual \emph{i} \eqn{\phi a_i v(\mu_i)[h'(\mu_i)]^2} (see Table 2.1 in McCullagh
and Nelder (1989) \url{ISBN:9780412317606}). For very large designs, this can be disabled as
the memory requirements can be prohibitive.

Calls the respective print methods of the linked covariance and mean function objects.

The matrices X and Z both have n rows, where n is the number of observations in the model/design.

\strong{Number of clusters}
Returns a data frame describing the number of independent clusters or groups at each level in the design. For example,
if there were cluster-periods nested in clusters, then the top level would be clusters, and the second level would be
cluster periods.

\strong{analysis}
The analysis function conducts a detailed design analysis using the analysis
model specified by the object. Data are simulated either using the same
data generating process, or using a different Design object specified by
the user to allow for model misspecification. On each iteration the model
is estimated with the simulated data \emph{y} using either the \code{MCML} function or
approximate parameters and standard errors using generalised least squares.
MCML is an exact maximum likelihood algorithm, and can be slow, so results
from previous simulations are saved in the design object and can be recalled
later. Deletion diagnostics are also calculated to calculate influential parts of
the design, although these are typically not useful for balanced
experimental designs.

The function returns an \code{glmmr.sim} object, which estimates and summarises:

\strong{Model fitting and simulation diagnostics}
Convergence failure percent and coverage. Maximum likelihood estimators
for GLMMs can fail to converge or reach the MLE. GLMMs can also be
susceptible to small sample biases where the relevant sample size is
at the level of clustering and correlation.

\strong{Error rates}
Type 2 (power), Type S (significance), and Type M (magnitude) errors are
reported.

\strong{p-value and confidence interval width distributions}

\strong{Deletion diagnostics}
For unbalanced designs and under model misspecifications, certain parts of
the design may have more influence than others over the estimate of interest,
or have a larger than desired effect. A summary of the DFBETA diagnostic
is provided.

\strong{Approximate power}
Calculates the approximate power of the design using the square root
of the relevant element of the GLS variance matrix:

\deqn{(X^T\Sigma^{-1}X)^{-1}}

Note that this is equivalent to using the "design effect" for many
models.

\strong{MCMCML}
Fits generalised linear mixed models using one of three algorithms: Markov Chain Newton
Raphson (MCNR), Markov Chain Expectation Maximisation (MCEM), or Maximum simulated
likelihood (MSL). All the algorithms are described by McCullagh (1997). For each iteration
of the algorithm the unobserved random effect terms (\eqn{\gamma}) are simulated
using Markov Chain Monte Carlo (MCMC) methods (we use Hamiltonian Monte Carlo through Stan),
and then these values are conditioned on in the subsequent steps to estimate the covariance
parameters and the mean function parameters (\eqn{\beta}). For all the algorithms,
the covariance parameter estimates are updated using an expectation maximisation step.
For the mean function parameters you can either use a Newton Raphson step (MCNR) or
an expectation maximisation step (MCEM). A simulated likelihood step can be added at the
end of either MCNR or MCEM, which uses an importance sampling technique to refine the
parameter estimates.

The accuracy of the algorithm depends on the user specified tolerance. For higher levels of
tolerance, larger numbers of MCMC samples are likely need to sufficiently reduce Monte Carlo error.

The function also offers different methods of obtaining standard errors. First, one can generate
estimates from the estimated Hessian matrix (\code{se.method = 'lik'}). Second, there are robust standard
errors using a sandwich estimator based on White (1982) (\code{se.method = 'robust'}).
Third, there are use approximate generalised least squares estimates based on the maximum likelihood
estimates of the covariance
parameters (\code{se.method = 'approx'}), or use a permutation test approach (\code{se.method = 'perm'}).
Note that the permutation test can be accessed separately with the function \code{permutation_test()}.

There are several options that can be specified to the function using the \code{options} argument.
The options should be provided as a list, e.g. \code{options = list(method="mcnr")}. The possible options are:
\itemize{
\item \code{b_se_only} TRUE (calculate standard errors of the mean function parameters only) or FALSE (calculate
all standard errors), default it FALSE.
\item \code{use_cmdstanr} TRUE (uses \code{cmdstanr} for the MCMC sampling, requires cmdstanr), or FALSE (uses \code{rstan}). Default is FALSE.
\item \code{skip_cov_optim} TRUE (skips the covariance parameter estimation step, and uses the values covariance$parameters), or
FALSE (run the whole algorithm)], default is FALSE
\item \code{sim_lik_step} TRUE (conduct a simulated likelihood step at the end of the algorithm), or FALSE (does
not do this step), defaults to FALSE.
\item \code{no_warnings} TRUE (do not report any warnings) or FALSE (report warnings), default to FALSE
\item \code{perm_type} Either \code{cov} (use weighted test statistic in permutation test) or \code{unw} (use unweighted
test statistic), defaults to \code{cov}. See \code{permutation_test()}.
\item \code{perm_iter} Number of iterations for the permutation test, default is 100.
\item \code{perm_parallel} TRUE (run permuation test in parallel) or FALSE (runs on a single thread), default to TRUE
\item \code{warmup_iter} Number of warmup iterations on each iteration for the MCMC sampler, default is 500
\item \code{perm_ci_steps} Number of steps for the confidence interval search procedure if using the permutation
test, default is 1000. See \code{permutation_test()}.
\item \code{fd_tol} The tolerance of the first difference method to estimate the Hessian and Gradient, default
is 1e-4.
}

\strong{Permutation tests}
If the user provided a re-randomisation function to the linked mean function object (see \link[glmmr]{MeanFunction}),
then a permuation test can be conducted. A new random assignment is generated on each iteration of the permutation test.
The test statistic can be either a quasi-score statistic, weighting the observations using the covariance matrix (\code{type="cov"}),
or an unweighted statistic that weights each observation in each cluster equally (\code{type="unw"}). The 1-alpha\%
confidence interval limits are estimated using an efficient iterative stochastic search procedure. On each step of the algorithm
a single permuation and test statistic is generated, and the current estimate of the confidence interval limit either
increased or decreased depedning on its value. The procedure converges in probability to the true limits, see Watson et al (2021)
and Garthwaite (1996).

\strong{MCMC}
Draws samples from the posterior distribution of the model parameters using Stan. Priors are specified using the \code{priors} argument.
Currently, only Gaussian (or half-Gaussian for covariance parameters) prior distributions are supported. The argument \code{priors}
accepts a list with three or four elements, \code{prior_b_mean}, \code{prior_b_sd} which are vectors specifying the prior mean and
standard deviation for the mean function parameters \eqn{\beta} in the model; \code{prior_g_sd} specifying the prior standard deviation
for the half-Gaussian prior for the covariance parameters, and optionally \code{sigma_sd} for the half-Gaussian prior for the scale
terms in models that have a scale parameter (Gaussian and Gamma currently). By default the function uses \code{rstan}, however the function
can optionally call \code{cmdstanr} instead if it is installed, using the option \code{use_cmdstanr=TRUE}. For further details on the use and
arguments that can be used, see \link[rstan]{sampling}.

\strong{Bayesian design analysis}
The Bayesian design analysis conducts multiple iterations of simulating data from a GLMM and then fitting a GLMM to analyse
the properties of the posterior distribution and model calibration to inform study design. Data are either simulated from the same
model as the analysis model, i.e. there is correct model specification (nothing is specified for the option \code{sim_design}), or data
are simulated from a different model (a \code{Design} object passed to the \code{sim_design} argument of this function) and then fit using
the \code{Design} object from which this function was called, i.e. with model misspecification. The function analyses four related statistics
summarising the design. First, the expected posterior variance; second, the variance of the posterior variance; third, the probability the
parameter of interest will be greater than some threshold; and fourth, simulation-based calibration (see Talts et al, 2021).

Model fitting is done using Stan's sampler (see \link[rstan]{sampling} and the \code{MCMC()} function in this class).
}
\examples{

## ------------------------------------------------
## Method `Design$new`
## ------------------------------------------------

#create a data frame describing a cross-sectional parallel cluster
#randomised trial
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)

#alternatively we can pass the data directly to Design
#here we will specify a cohort study
df <- nelder(~ind(20) > t(6))
df$int <- 0
df[df$t > 3, 'int'] <- 1

des <- Design$new(
covariance = list(
  data=df,
  formula = ~ (1|ar1(t)*gr(ind)),
  parameters = c(0.8,1)),
mean.function = list(
  formula = ~int + factor(t),
  data=df,
  parameters = rep(0,7),
  family = poisson()))
                  
#an example of a spatial grid with two time points
df <- nelder(~ (x(10)*y(10))*t(2))
spt_design <- Design$new(covariance = list(data=df,
                                           formula = ~(1|fexp(x,y)*ar1(t)),
                                           parameters =c(0.2,0.1,0.8)),
                         mean.function = list(data=df,
                                              formula = ~ 1,
                                              parameters = c(0.5),
                                              family=poisson())) 

## ------------------------------------------------
## Method `Design$n_cluster`
## ------------------------------------------------

df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)
des$n_cluster() ## returns two levels of 10 and 50

## ------------------------------------------------
## Method `Design$analysis`
## ------------------------------------------------

\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)
# analysis using MCML mcem algorithm
test1 <- des$analysis(type="sim",
                     iter=100,
                     par=6,
                     parallel = FALSE,
                     verbose = FALSE,
                     method = "mcem",
                     m = 100)
#an analysis using the permutation test option and MCNR
test2 <- des$analysis(type="sim",
                     iter=100,
                     se.method="perm",
                     par=6,
                     parallel = FALSE,
                     verbose = FALSE,
                     options = list(
                       perm_type="unw", perm_iter=100,
                       perm_parallel=FALSE,perm_ci_steps=1000)
                     method = "mcnr",
                     m = 100)
#returning previously saved sim data
test3 <- des$analysis(type="sim_data")

#to test model misspecification we can simulate from a different model
cov2 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)*ar1(t)),
  parameters = c(0.25,0.8)
)
des2 <- Design$new(
  covariance = cov2,
  mean.function = mf1,
  var_par = 1
)    
 test4 <- des$analysis(type="sim",
                     iter=100,
                     sim_design = des2,
                     par=6,
                     parallel = FALSE,
                     verbose = FALSE,
                     method = "mcem",
                     m = 100)                       
}

## ------------------------------------------------
## Method `Design$power`
## ------------------------------------------------

df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)
des$power(6,0.5) #power of 0.79

## ------------------------------------------------
## Method `Design$subset_rows`
## ------------------------------------------------

#generate a stepped wedge design and remove the first sequence
des <- stepped_wedge(8,10,icc=0.05)
ids_to_keep <- which(des$mean_function$data$J!=1)
des$subset_rows(ids_to_keep)

## ------------------------------------------------
## Method `Design$subset_cols`
## ------------------------------------------------

#generate a stepped wedge design and remove first and last time periods
des <- stepped_wedge(8,10,icc=0.05)
des$subset_cols(c(2:8,10))

## ------------------------------------------------
## Method `Design$plot`
## ------------------------------------------------

\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
des$plot(x="cl",y="t",treat="int")
}

## ------------------------------------------------
## Method `Design$sim_data`
## ------------------------------------------------

df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()

## ------------------------------------------------
## Method `Design$check`
## ------------------------------------------------

df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
des$check() #does nothing
des$covariance$parameters <- c(0.1,0.9)
des$check() #updates 
des$mean_function$parameters <- c(rnorm(5),0.1)
des$check() #updates 

## ------------------------------------------------
## Method `Design$MCML`
## ------------------------------------------------

\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the models using MCEM but does not estimate standard errors
fit1 <- des$MCML(y = ysim,
  se.method = "none")
#fits the models using MCNR but does not estimate standard errors
fit2 <- des$MCML(y = ysim,
  se.method = "none",
  method="mcnr")
#fits the models and uses permutation tests for parameter of interest
fit3 <- des$MCML(y = ysim,
  se.method = "perm",
  permutation.par = 6,
  options = list(
    perm_type="unw",
    perm_iter=1000,
    perm_parallel=FALSE,
    perm_ci_steps=1000
  ))
 #adds a simulated likelihood step after the MCEM algorithm
fit4 <- des$MCML(y = des$sim_data(),
  se.method = "none",
  options = list(
    sim_lik_step=TRUE
  ))  
}

## ------------------------------------------------
## Method `Design$dfbeta`
## ------------------------------------------------

df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
des$dfbeta(ysim,6)

## ------------------------------------------------
## Method `Design$permutation_test`
## ------------------------------------------------

\dontrun{
 df <- nelder(~(cl(6)*t(5)) > ind(5))
 df$int <- 0
 df[df$cl > 3, 'int'] <- 1
 #generate function that produces random allocations
 treatf <- function(){
             tr <- sample(rep(c(0,1),each=3),6,replace = FALSE)
             rep(tr,each=25)
             }
 mf1 <- MeanFunction$new(
   formula = ~ factor(t) + int - 1,
   data=df,
   parameters = c(rep(0,5),0.6),
   family =gaussian(),
   treat_var = "int",
   random_function = treatf)
 cov1 <- Covariance$new(
   data = df,
   formula = ~ (1|gr(cl)),
   parameters = c(0.25))
 des <- Design$new(
   covariance = cov1,
   mean.function = mf1,
   var_par = 1)
 #run MCML to get parameter estimate:
 fit1 <- des$MCML(y = ysim,
  se.method = "none")
 perm1 <- des$permutation_test(
   y=ysim,
   permutation.par=6,
   start = fit1$coefficients$est[6],
   type="unw",
   iter = 1000,
   nsteps = 1000) 
}

## ------------------------------------------------
## Method `Design$MCMC`
## ------------------------------------------------

\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the model with default priors 
fit1 <- des$MCMC(y=ysim)
#specify priors
fit2 <- des$MCMC(y=ysim,
  priors = list(
    prior_b_mean = rep(0,6),
    prior_b_sd = c(rep(3,5),1),
    prior_g_sd = rep(1,2)))
}

## ------------------------------------------------
## Method `Design$analysis_bayesian`
## ------------------------------------------------

\dontrun{
#' df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
test <- des$analysis_bayesian(iter=10,
  par=6,
  warmup_iter = 200,
  sampling_iter = 500,
  parallel = FALSE,
  verbose=FALSE)
#to examine misspecification we can sample from a different model 
des2 <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)),
    parameters = c(0.25)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
test2 <- des$analysis_bayesian(iter=10,
  par=6,
  sim_design=des2,
  warmup_iter = 200,
  sampling_iter = 500,
  parallel = FALSE,
  verbose=FALSE)
}
}
\references{
Braun and Feng
McCullagh
Stan
McCullagh and Nelder
Approx GLMMs paper
Watson confidence interval

Watson et al. Arxiv
Braun and Feng
Gail
Garthwaite

SBC paper (Talts)
APV paper
}
\seealso{
\link[glmmr]{nelder}, \link[glmmr]{MeanFunction}, \link[glmmr]{Covariance}

\link[glmmr]{print.glmmr.sim}, \code{MCML}

\link[rstan]{sampling}, \link[rstan]{stan}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{covariance}}{A \link[glmmr]{Covariance} object defining the random effects covariance.}

\item{\code{mean_function}}{A \link[glmmr]{MeanFunction} object, defining the mean function for the model, including the data and covariate design matrix X.}

\item{\code{exp_condition}}{A vector indicting the unique experimental conditions for each observation, see Details.}

\item{\code{Sigma}}{The overall covariance matrix for the observations. Calculated and updated automatically as \eqn{W^{-1} + ZDZ^T} where W is an n x n
diagonal matrix with elements on the diagonal equal to the GLM iterated weights. See Details.}

\item{\code{var_par}}{Scale parameter required for some distributions (Gaussian, Gamma, Beta).}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-fitted}{\code{Design$fitted()}}
\item \href{#method-new}{\code{Design$new()}}
\item \href{#method-print}{\code{Design$print()}}
\item \href{#method-n}{\code{Design$n()}}
\item \href{#method-n_cluster}{\code{Design$n_cluster()}}
\item \href{#method-analysis}{\code{Design$analysis()}}
\item \href{#method-power}{\code{Design$power()}}
\item \href{#method-subset_rows}{\code{Design$subset_rows()}}
\item \href{#method-subset_cols}{\code{Design$subset_cols()}}
\item \href{#method-plot}{\code{Design$plot()}}
\item \href{#method-sim_data}{\code{Design$sim_data()}}
\item \href{#method-check}{\code{Design$check()}}
\item \href{#method-MCML}{\code{Design$MCML()}}
\item \href{#method-dfbeta}{\code{Design$dfbeta()}}
\item \href{#method-permutation_test}{\code{Design$permutation_test()}}
\item \href{#method-MCMC}{\code{Design$MCMC()}}
\item \href{#method-analysis_bayesian}{\code{Design$analysis_bayesian()}}
\item \href{#method-clone}{\code{Design$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitted"></a>}}
\if{latex}{\out{\hypertarget{method-fitted}{}}}
\subsection{Method \code{fitted()}}{
Return predicted values based on the currently stored parameter values in \code{mean_function}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$fitted(type = "link")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{One of either "\code{link}" for values on the scale of the link function, or "\code{response}"
for values on the scale of the response}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[Matrix]{Matrix} class object containing the predicted values
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new Design object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$new(
  covariance,
  mean.function,
  var_par = NULL,
  verbose = TRUE,
  skip.sigma = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{covariance}}{Either a \link[glmmr]{Covariance} object, or an equivalent list of arguments
that can be passed to \code{Covariance} to create a new object.}

\item{\code{mean.function}}{Either a \link[glmmr]{MeanFunction} object, or an equivalent list of arguments
that can be passed to \code{MeanFunction} to create a new object.}

\item{\code{var_par}}{Scale parameter required for some distributions, including Gaussian. Default is NULL.}

\item{\code{verbose}}{Logical indicating whether to provide detailed output}

\item{\code{skip.sigma}}{Logical indicating whether to skip the creating of the covariance matrix Sigma. For
very large designs with thousands of observations or more, the covariance matrix will be too big to
fit in memory, so this option will prevent sigma being created.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new Design class object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{#create a data frame describing a cross-sectional parallel cluster
#randomised trial
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)

#alternatively we can pass the data directly to Design
#here we will specify a cohort study
df <- nelder(~ind(20) > t(6))
df$int <- 0
df[df$t > 3, 'int'] <- 1

des <- Design$new(
covariance = list(
  data=df,
  formula = ~ (1|ar1(t)*gr(ind)),
  parameters = c(0.8,1)),
mean.function = list(
  formula = ~int + factor(t),
  data=df,
  parameters = rep(0,7),
  family = poisson()))
                  
#an example of a spatial grid with two time points
df <- nelder(~ (x(10)*y(10))*t(2))
spt_design <- Design$new(covariance = list(data=df,
                                           formula = ~(1|fexp(x,y)*ar1(t)),
                                           parameters =c(0.2,0.1,0.8)),
                         mean.function = list(data=df,
                                              formula = ~ 1,
                                              parameters = c(0.5),
                                              family=poisson())) 
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print method for \code{Design} class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$print()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{ignored}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n"></a>}}
\if{latex}{\out{\hypertarget{method-n}{}}}
\subsection{Method \code{n()}}{
Returns the number of observations in the model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$n(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{ignored}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_cluster"></a>}}
\if{latex}{\out{\hypertarget{method-n_cluster}{}}}
\subsection{Method \code{n_cluster()}}{
Returns the number of clusters at each level
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$n_cluster()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{ignored}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data frame with the level, number of clusters, and variables describing each level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)
des$n_cluster() ## returns two levels of 10 and 50
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-analysis"></a>}}
\if{latex}{\out{\hypertarget{method-analysis}{}}}
\subsection{Method \code{analysis()}}{
Run a design analysis of the model via simulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$analysis(
  type,
  iter,
  par,
  alpha = 0.05,
  sim_design,
  parallel = TRUE,
  verbose = TRUE,
  options = list(),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{One of either \code{sim_data} (recalls saved data from a previous
call to this function), \code{sim} (full simulation using MCML), or \code{sim_approx} (
uses GLS to approximate the MLE and standard errors)}

\item{\code{iter}}{Integer. The number of iterations of the simulation to run}

\item{\code{par}}{Integer. The parameter of interest for which design analysis
statistics should be calculated. Refers to the column of X.}

\item{\code{alpha}}{Numeric. The type I error rate.}

\item{\code{sim_design}}{Optional. A different \code{Design} object that will be used to
simulate data to allow for model misspecification.}

\item{\code{parallel}}{Logical indicating whether to run the simulations in parallel}

\item{\code{verbose}}{Logical indicating whether to report detailed output. Defaults to TRUE.}

\item{\code{options}}{Optional. A named list to pass to the options argument of \code{MCML}}

\item{\code{...}}{Additional arguments passed to \code{MCML}, see below.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{glmmr.sim} object containing the estimates from all the simulations, including
standard errors, deletion diagnostic statistics, and details about the simulation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)
# analysis using MCML mcem algorithm
test1 <- des$analysis(type="sim",
                     iter=100,
                     par=6,
                     parallel = FALSE,
                     verbose = FALSE,
                     method = "mcem",
                     m = 100)
#an analysis using the permutation test option and MCNR
test2 <- des$analysis(type="sim",
                     iter=100,
                     se.method="perm",
                     par=6,
                     parallel = FALSE,
                     verbose = FALSE,
                     options = list(
                       perm_type="unw", perm_iter=100,
                       perm_parallel=FALSE,perm_ci_steps=1000)
                     method = "mcnr",
                     m = 100)
#returning previously saved sim data
test3 <- des$analysis(type="sim_data")

#to test model misspecification we can simulate from a different model
cov2 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)*ar1(t)),
  parameters = c(0.25,0.8)
)
des2 <- Design$new(
  covariance = cov2,
  mean.function = mf1,
  var_par = 1
)    
 test4 <- des$analysis(type="sim",
                     iter=100,
                     sim_design = des2,
                     par=6,
                     parallel = FALSE,
                     verbose = FALSE,
                     method = "mcem",
                     m = 100)                       
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-power"></a>}}
\if{latex}{\out{\hypertarget{method-power}{}}}
\subsection{Method \code{power()}}{
Approximate power of the design using the GLS variance
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$power(par, value, alpha = 0.05)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{par}}{Integer indicating which parameter of the design the power
should be calculated for. Refers to the order of parameters and column
of X}

\item{\code{value}}{Numeric specifying the value of the parameter to calculate
the power at}

\item{\code{alpha}}{Numeric between zero and one indicating the type I error rate.
Default of 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A value between zero and one indicating the approximate power of the
design.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1

mf1 <- MeanFunction$new(
  formula = ~ factor(t) + int - 1,
  data=df,
  parameters = c(rep(0,5),0.6),
  family = gaussian()
)
cov1 <- Covariance$new(
  data = df,
  formula = ~ (1|gr(cl)) + (1|gr(cl*t)),
  parameters = c(0.25,0.1)
)
des <- Design$new(
  covariance = cov1,
  mean.function = mf1,
  var_par = 1
)
des$power(6,0.5) #power of 0.79
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-subset_rows"></a>}}
\if{latex}{\out{\hypertarget{method-subset_rows}{}}}
\subsection{Method \code{subset_rows()}}{
Subsets the design keeping specified observations only

Given a vector of row indices, the corresponding rows will be kept and the
other rows will be removed from the mean function and covariance
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$subset_rows(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{Integer or vector integers listing the rows to keep}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The function updates the object and nothing is returned
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{#generate a stepped wedge design and remove the first sequence
des <- stepped_wedge(8,10,icc=0.05)
ids_to_keep <- which(des$mean_function$data$J!=1)
des$subset_rows(ids_to_keep)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-subset_cols"></a>}}
\if{latex}{\out{\hypertarget{method-subset_cols}{}}}
\subsection{Method \code{subset_cols()}}{
Subsets the columns of the design

Removes the specified columns from the linked mean function object's X matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$subset_cols(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{Integer or vector of integers specifying the indexes of the columns to keep}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The function updates the object and nothing is returned
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{#generate a stepped wedge design and remove first and last time periods
des <- stepped_wedge(8,10,icc=0.05)
des$subset_cols(c(2:8,10))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
Generates a plot of the design

Generates a 'bubble' plot of the design with respect to two or three variables
in which the size of the points at each location are scaled by the number of observations at that
location. For example, for a cluster randomised trial the user might specify
time period on the x-axis and cluster ID on the y-axis. For a geospatial
sampling design the x and y axes might represent spatial dimensions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$plot(x, y, z = NULL, treat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{String naming a column in the data frame in the linked covariance object (self$covariance$data)
for the x-axis}

\item{\code{y}}{String naming a column in the data frame in the linked covariance object (self$covariance$data)
for the y-axis}

\item{\code{z}}{Optional. String naming a column in the data frame in the linked covariance object (self$covariance$data)
for a 'third axis' used for faceting}

\item{\code{treat}}{String naming a column in the data frame in the linked mean function
object (self$mean_function$data) that identifies the treatment status of the observations
at each location, used to set the colour of the points in the plot}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[ggplot2]{ggplot2} plot
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
des$plot(x="cl",y="t",treat="int")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sim_data"></a>}}
\if{latex}{\out{\hypertarget{method-sim_data}{}}}
\subsection{Method \code{sim_data()}}{
Generates a realisation of the design

Generates a single vector of outcome data based upon the
specified GLMM design
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$sim_data(type = "y")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{Either 'y' to return just the outcome data, or 'data'
to return a data frame with the simulated outcome data alongside the model data}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Either a vector or a data frame
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-check"></a>}}
\if{latex}{\out{\hypertarget{method-check}{}}}
\subsection{Method \code{check()}}{
Checks for any changes in linked objects and updates.

Checks for any changes in any object and updates all linked objects if
any are detected. Generally called automatically.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$check(verbose = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{verbose}}{Logical indicating whether to report if any updates are made, defaults to TRUE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Linked objects are updated by nothing is returned
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
des$check() #does nothing
des$covariance$parameters <- c(0.1,0.9)
des$check() #updates 
des$mean_function$parameters <- c(rnorm(5),0.1)
des$check() #updates 
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MCML"></a>}}
\if{latex}{\out{\hypertarget{method-MCML}{}}}
\subsection{Method \code{MCML()}}{
Markov Chain Monte Carlo Maximum Likelihood  model fitting
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$MCML(
  y,
  start,
  se.method = "lik",
  method = "mcnr",
  permutation.par,
  verbose = TRUE,
  tol = 0.01,
  m = 100,
  max.iter = 30,
  options = list()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{A numeric vector of outcome data}

\item{\code{start}}{Optional. A numeric vector indicating starting values for the MCML algorithm iterations.
If this is not specified then the parameter values stored in the linked mean function object will be used.}

\item{\code{se.method}}{One of either \code{'lik'}, \code{'approx'}, \code{'perm'}, or \code{'none'}, see Details.}

\item{\code{method}}{The MCML algorithm to use, either \code{mcem} or \code{mcnr}, see Details. Default is \code{mcem}.}

\item{\code{permutation.par}}{Optional. Integer specifing the index of the parameter if permutation tests are being used.}

\item{\code{verbose}}{Logical indicating whether to provide detailed output, defaults to TRUE.}

\item{\code{tol}}{Numeric value, tolerance of the MCML algorithm, the maximum difference in parameter estimates
between iterations at which to stop the algorithm.}

\item{\code{m}}{Integer. The number of MCMC draws of the random effects on each iteration.}

\item{\code{max.iter}}{Integer. The maximum number of iterations of the MCML algorithm.}

\item{\code{options}}{An optional list providing options to the algorithm, see Details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{mcml} object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the models using MCEM but does not estimate standard errors
fit1 <- des$MCML(y = ysim,
  se.method = "none")
#fits the models using MCNR but does not estimate standard errors
fit2 <- des$MCML(y = ysim,
  se.method = "none",
  method="mcnr")
#fits the models and uses permutation tests for parameter of interest
fit3 <- des$MCML(y = ysim,
  se.method = "perm",
  permutation.par = 6,
  options = list(
    perm_type="unw",
    perm_iter=1000,
    perm_parallel=FALSE,
    perm_ci_steps=1000
  ))
 #adds a simulated likelihood step after the MCEM algorithm
fit4 <- des$MCML(y = des$sim_data(),
  se.method = "none",
  options = list(
    sim_lik_step=TRUE
  ))  
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dfbeta"></a>}}
\if{latex}{\out{\hypertarget{method-dfbeta}{}}}
\subsection{Method \code{dfbeta()}}{
Calculates DFBETA deletion diagnostic values

Calculates the DFBETA deletion diagnostic statistic for each observation for the
specified parameter.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$dfbeta(y, par)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{Numeric vector of outcomes data}

\item{\code{par}}{Integer indicating which parameter, as a column of X, to report the
deletion diagnostics for.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector of length self$n() with the value of DFBETA for each observation for
the specified parameter
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
des$dfbeta(ysim,6)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-permutation_test"></a>}}
\if{latex}{\out{\hypertarget{method-permutation_test}{}}}
\subsection{Method \code{permutation_test()}}{
Conducts a permuation test

Estimates p-values and confidence intervals using a permutation test
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$permutation_test(
  y,
  permutation.par,
  start,
  iter = 1000,
  nsteps = 1000,
  type = "cov",
  parallel = TRUE,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{Numeric vector of outcome data}

\item{\code{permutation.par}}{Integer indicator which parameter to conduct a permutation
test for. Refers to a column of the X matrix.}

\item{\code{start}}{Value of the parameter. Used both as a starting value for the algorithms
and as a best estimate for the confidence interval search procedure.}

\item{\code{iter}}{Integer. Number of iterations of the permuation test to conduct}

\item{\code{nsteps}}{Integer. Number of steps of the confidence interval search procedure}

\item{\code{type}}{Either \code{cov} for a test statistic weighted by the covariance matrix, or
\code{unw} for an unweighted test statistic. See Details.}

\item{\code{parallel}}{Logical indicating whether to run the tests in parallel}

\item{\code{verbose}}{Logical indicating whether to report detailed output}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the estimated p-value and the estimated lower and upper 95\% confidence interval
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
 df <- nelder(~(cl(6)*t(5)) > ind(5))
 df$int <- 0
 df[df$cl > 3, 'int'] <- 1
 #generate function that produces random allocations
 treatf <- function(){
             tr <- sample(rep(c(0,1),each=3),6,replace = FALSE)
             rep(tr,each=25)
             }
 mf1 <- MeanFunction$new(
   formula = ~ factor(t) + int - 1,
   data=df,
   parameters = c(rep(0,5),0.6),
   family =gaussian(),
   treat_var = "int",
   random_function = treatf)
 cov1 <- Covariance$new(
   data = df,
   formula = ~ (1|gr(cl)),
   parameters = c(0.25))
 des <- Design$new(
   covariance = cov1,
   mean.function = mf1,
   var_par = 1)
 #run MCML to get parameter estimate:
 fit1 <- des$MCML(y = ysim,
  se.method = "none")
 perm1 <- des$permutation_test(
   y=ysim,
   permutation.par=6,
   start = fit1$coefficients$est[6],
   type="unw",
   iter = 1000,
   nsteps = 1000) 
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MCMC"></a>}}
\if{latex}{\out{\hypertarget{method-MCMC}{}}}
\subsection{Method \code{MCMC()}}{
Fit the GLMM using MCMC

Fit the GLMM using MCMC. The function calls a Stan program to draw posterior samples.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$MCMC(
  y,
  priors,
  warmup_iter = 1000,
  sampling_iter = 1000,
  chains = 4,
  use_cmdstanr = FALSE,
  parallel = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{Numeric vector providing the outcome data}

\item{\code{priors}}{A named list specifying the prior mean and standard deviation for the Gaussian prior distributions, see Details.}

\item{\code{warmup_iter}}{A positive integer specifying the number of warmup iterations for each MCMC chain}

\item{\code{sampling_iter}}{A positive integer specifying the number of sampling iterations for each MCMC chain}

\item{\code{chains}}{A positive integer specifying the number of MCMC chains to run}

\item{\code{use_cmdstanr}}{Logical indicating whether to use \code{cmdstanr}, the default is FALSE, which will use \code{rstan}}

\item{\code{parallel}}{Logical indicating whether to run the chains in parallel}

\item{\code{...}}{Additional arguments to pass to \link[rstan]{sampling}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Either an S4 \code{stanfit} object returned by \link[rstan]{sampling}, or a \code{cmdstanr} environment, depending on the sampler used.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the model with default priors 
fit1 <- des$MCMC(y=ysim)
#specify priors
fit2 <- des$MCMC(y=ysim,
  priors = list(
    prior_b_mean = rep(0,6),
    prior_b_sd = c(rep(3,5),1),
    prior_g_sd = rep(1,2)))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-analysis_bayesian"></a>}}
\if{latex}{\out{\hypertarget{method-analysis_bayesian}{}}}
\subsection{Method \code{analysis_bayesian()}}{
Bayesian design analysis

Runs a Bayesian design analysis using simulated data
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$analysis_bayesian(
  iter,
  par,
  priors,
  threshold = 0,
  sim_design,
  priors_sim,
  warmup_iter = 200,
  sampling_iter = 200,
  chains = 1,
  parallel = TRUE,
  verbose = TRUE,
  use_cmdstanr = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{iter}}{A positive integer specifying the number of simulation iterations to run}

\item{\code{par}}{A positive interger specifying the index of the parameter in the mean function to analyse, refers specifically to the column
of X}

\item{\code{priors}}{A named list specifying the priors, see Details in the \code{MCMC()} function in this class}

\item{\code{threshold}}{A number specifying the threshold. The probability that the parameter of interest is greater than this threshold will be calculated.}

\item{\code{sim_design}}{Optional. A different \code{Design} object that should be used to simulate the data for the simulation.}

\item{\code{priors_sim}}{Optional. A named list of the same structure as \code{priors} the specifies the priors from which to simulate data, if they are different
to the priors for model fitting.}

\item{\code{warmup_iter}}{A positive integer specifying the number of warmup iterations for each MCMC chain when fitting the model on each simulation
iteration.}

\item{\code{sampling_iter}}{A positive integer specifying the number of sampling iterations for each MCMC chain when fitting the model on each simulation
iteration.}

\item{\code{chains}}{A positive integer specifying the number of MCMC chains when fitting the model on each simulation
iteration.}

\item{\code{parallel}}{Logical indicating whether to run the MCMC chains in parallel}

\item{\code{verbose}}{Logical indicating whether to provide detailed output of the progress of simulations.}

\item{\code{use_cmdstanr}}{Logical indicating whether to use \code{cmdstanr} instead of \code{rstan}, the default is FALSE (i.e. use \code{rstan})}

\item{\code{...}}{Additional options to pass to \code{rstan::sampling} or \code{cmdstanr::sample}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{glmmr.sim} object containing the samples of posterior variance and relevant probabilities to summarise the analysis
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
#' df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
test <- des$analysis_bayesian(iter=10,
  par=6,
  warmup_iter = 200,
  sampling_iter = 500,
  parallel = FALSE,
  verbose=FALSE)
#to examine misspecification we can sample from a different model 
des2 <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)),
    parameters = c(0.25)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
test2 <- des$analysis_bayesian(iter=10,
  par=6,
  sim_design=des2,
  warmup_iter = 200,
  sampling_iter = 500,
  parallel = FALSE,
  verbose=FALSE)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Design$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
