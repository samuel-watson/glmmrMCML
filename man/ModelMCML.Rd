% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R6ModelExtMCML.R
\name{ModelMCML}
\alias{ModelMCML}
\title{Extension to the Model class to use Markov Chain Monte Carlo Maximum Likelihood}
\description{
Extension to the Model class to use Markov Chain Monte Carlo Maximum Likelihood

Extension to the Model class to use Markov Chain Monte Carlo Maximum Likelihood
}
\details{
An R6 class representing a GLMM and study design

For the generalised linear mixed model

\deqn{Y \sim F(\mu,\sigma)}
\deqn{\mu = h^-1(X\beta + Z\gamma)}
\deqn{\gamma \sim MVN(0,D)}

where h is the link function. A Model in comprised of a \link[glmmr]{MeanFunction} object, which defines the family F,
link function h, and fixed effects design matrix X, and a \link[glmmr]{Covariance} object, which defines Z and D. The class provides
methods for analysis and simulation with these models.

This class provides methods for: data simulation (\code{sim_data()} and \code{fitted()}), model fitting using Markov Chain
Monte Carlo Maximum Likelihood (MCML) methods (\code{MCML()}), design analysis via simulation including power (\code{analysis()}),
deletion diagnostics (\code{dfbeta()}), and permutation tests including p-values and confidence intervals (\code{permutation()}).

The class by default calculates the covariance matrix of the observations as:

\deqn{\Sigma = W^{-1} + ZDZ^T}

where \emph{W} is a diagonal matrix with the WLS iterated weights for each observation equal
to, for individual \emph{i} \eqn{\phi a_i v(\mu_i)[h'(\mu_i)]^2} (see Table 2.1 in McCullagh
and Nelder (1989) \url{ISBN:9780412317606}). For very large designs, this can be disabled as
the memory requirements can be prohibitive.

\strong{MCMCML}
Fits generalised linear mixed models using one of three algorithms: Markov Chain Newton
Raphson (MCNR), Markov Chain Expectation Maximisation (MCEM), or Maximum simulated
likelihood (MSL). All the algorithms are described by McCullagh (1997). For each iteration
of the algorithm the unobserved random effect terms (\eqn{\gamma}) are simulated
using Markov Chain Monte Carlo (MCMC) methods (we use Hamiltonian Monte Carlo through Stan),
and then these values are conditioned on in the subsequent steps to estimate the covariance
parameters and the mean function parameters (\eqn{\beta}). For all the algorithms,
the covariance parameter estimates are updated using an expectation maximisation step.
For the mean function parameters you can either use a Newton Raphson step (MCNR) or
an expectation maximisation step (MCEM). A simulated likelihood step can be added at the
end of either MCNR or MCEM, which uses an importance sampling technique to refine the
parameter estimates.

The accuracy of the algorithm depends on the user specified tolerance. For higher levels of
tolerance, larger numbers of MCMC samples are likely need to sufficiently reduce Monte Carlo error.

The function also offers different methods of obtaining standard errors. First, one can generate
estimates from the estimated Hessian matrix (\code{se.method = 'lik'}). Second, there are robust standard
errors using a sandwich estimator based on White (1982) (\code{se.method = 'robust'}).
Third, there are use approximate generalised least squares estimates based on the maximum likelihood
estimates of the covariance
parameters (\code{se.method = 'approx'}), or use a permutation test approach (\code{se.method = 'perm'}).
Note that the permutation test can be accessed separately with the function \code{permutation_test()}.

There are several options that can be specified to the function using the \code{options} argument.
The options should be provided as a list, e.g. \code{options = list(method="mcnr")}. The possible options are:
\itemize{
\item \code{b_se_only} TRUE (calculate standard errors of the mean function parameters only) or FALSE (calculate
all standard errors), default it FALSE.
\item \code{use_cmdstanr} TRUE (uses \code{cmdstanr} for the MCMC sampling, requires cmdstanr), or FALSE (uses \code{rstan}). Default is FALSE.
\item \code{skip_cov_optim} TRUE (skips the covariance parameter estimation step, and uses the values covariance$parameters), or
FALSE (run the whole algorithm)], default is FALSE
\item \code{sim_lik_step} TRUE (conduct a simulated likelihood step at the end of the algorithm), or FALSE (does
not do this step), defaults to FALSE.
\item \code{no_warnings} TRUE (do not report any warnings) or FALSE (report warnings), default to FALSE
\item \code{perm_type} Either \code{cov} (use weighted test statistic in permutation test) or \code{unw} (use unweighted
test statistic), defaults to \code{cov}. See \code{permutation_test()}.
\item \code{perm_iter} Number of iterations for the permutation test, default is 100.
\item \code{perm_parallel} TRUE (run permuation test in parallel) or FALSE (runs on a single thread), default to TRUE
\item \code{warmup_iter} Number of warmup iterations on each iteration for the MCMC sampler, default is 500
\item \code{perm_ci_steps} Number of steps for the confidence interval search procedure if using the permutation
test, default is 1000. See \code{permutation_test()}.
\item \code{fd_tol} The tolerance of the first difference method to estimate the Hessian and Gradient, default
is 1e-4.
}
}
\examples{

## ------------------------------------------------
## Method `ModelMCML$MCML`
## ------------------------------------------------

\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the models using MCEM but does not estimate standard errors
fit1 <- des$MCML(y = ysim,
  se.method = "none")
#fits the models using MCNR but does not estimate standard errors
fit2 <- des$MCML(y = ysim,
  se.method = "none",
  method="mcnr")
#fits the models and uses permutation tests for parameter of interest
fit3 <- des$MCML(y = ysim,
  se.method = "perm",
  permutation.par = 6,
  options = list(
    perm_type="unw",
    perm_iter=1000,
    perm_parallel=FALSE,
    perm_ci_steps=1000
  ))
 #adds a simulated likelihood step after the MCEM algorithm
fit4 <- des$MCML(y = des$sim_data(),
  se.method = "none",
  options = list(
    sim_lik_step=TRUE
  ))  
}
}
\references{
Braun and Feng
McCullagh
Stan
McCullagh and Nelder
Approx GLMMs paper
Watson confidence interval
}
\section{Super class}{
\code{\link[glmmrBase:Model]{glmmrBase::Model}} -> \code{ModelMCML}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ModelMCML-MCML}{\code{ModelMCML$MCML()}}
\item \href{#method-ModelMCML-clone}{\code{ModelMCML$clone()}}
}
}
\if{html}{\out{
<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="check"><a href='../../glmmrBase/html/Model.html#method-Model-check'><code>glmmrBase::Model$check()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="fitted"><a href='../../glmmrBase/html/Model.html#method-Model-fitted'><code>glmmrBase::Model$fitted()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="information_matrix"><a href='../../glmmrBase/html/Model.html#method-Model-information_matrix'><code>glmmrBase::Model$information_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="initialize"><a href='../../glmmrBase/html/Model.html#method-Model-initialize'><code>glmmrBase::Model$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="n"><a href='../../glmmrBase/html/Model.html#method-Model-n'><code>glmmrBase::Model$n()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="n_cluster"><a href='../../glmmrBase/html/Model.html#method-Model-n_cluster'><code>glmmrBase::Model$n_cluster()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="print"><a href='../../glmmrBase/html/Model.html#method-Model-print'><code>glmmrBase::Model$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="sim_data"><a href='../../glmmrBase/html/Model.html#method-Model-sim_data'><code>glmmrBase::Model$sim_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="subset_cols"><a href='../../glmmrBase/html/Model.html#method-Model-subset_cols'><code>glmmrBase::Model$subset_cols()</code></a></span></li>
<li><span class="pkg-link" data-pkg="glmmrBase" data-topic="Model" data-id="subset_rows"><a href='../../glmmrBase/html/Model.html#method-Model-subset_rows'><code>glmmrBase::Model$subset_rows()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelMCML-MCML"></a>}}
\if{latex}{\out{\hypertarget{method-ModelMCML-MCML}{}}}
\subsection{Method \code{MCML()}}{
Markov Chain Monte Carlo Maximum Likelihood  model fitting
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelMCML$MCML(
  y,
  start,
  se.method = "lik",
  method = "mcnr",
  permutation.par,
  verbose = TRUE,
  tol = 0.01,
  m = 100,
  max.iter = 30,
  options = list()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{A numeric vector of outcome data}

\item{\code{start}}{Optional. A numeric vector indicating starting values for the MCML algorithm iterations.
If this is not specified then the parameter values stored in the linked mean function object will be used.}

\item{\code{se.method}}{One of either \code{'lik'}, \code{'approx'}, \code{'perm'}, or \code{'none'}, see Details.}

\item{\code{method}}{The MCML algorithm to use, either \code{mcem} or \code{mcnr}, see Details. Default is \code{mcem}.}

\item{\code{permutation.par}}{Optional. Integer specifing the index of the parameter if permutation tests are being used.}

\item{\code{verbose}}{Logical indicating whether to provide detailed output, defaults to TRUE.}

\item{\code{tol}}{Numeric value, tolerance of the MCML algorithm, the maximum difference in parameter estimates
between iterations at which to stop the algorithm.}

\item{\code{m}}{Integer. The number of MCMC draws of the random effects on each iteration.}

\item{\code{max.iter}}{Integer. The maximum number of iterations of the MCML algorithm.}

\item{\code{options}}{An optional list providing options to the algorithm, see Details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{mcml} object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the models using MCEM but does not estimate standard errors
fit1 <- des$MCML(y = ysim,
  se.method = "none")
#fits the models using MCNR but does not estimate standard errors
fit2 <- des$MCML(y = ysim,
  se.method = "none",
  method="mcnr")
#fits the models and uses permutation tests for parameter of interest
fit3 <- des$MCML(y = ysim,
  se.method = "perm",
  permutation.par = 6,
  options = list(
    perm_type="unw",
    perm_iter=1000,
    perm_parallel=FALSE,
    perm_ci_steps=1000
  ))
 #adds a simulated likelihood step after the MCEM algorithm
fit4 <- des$MCML(y = des$sim_data(),
  se.method = "none",
  options = list(
    sim_lik_step=TRUE
  ))  
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelMCML-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ModelMCML-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelMCML$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
