% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R6ModelExtMCML.R
\name{MCML}
\alias{MCML}
\title{Markov Chain Monte Carlo Maximum Likelihood  model fitting}
\usage{
MCML(
  y,
  start,
  se.method = "lik",
  method = "mcnr",
  permutation.par,
  verbose = TRUE,
  tol = 0.01,
  m = 100,
  max.iter = 30,
  options = list()
)
}
\arguments{
\item{y}{A numeric vector of outcome data}

\item{start}{Optional. A numeric vector indicating starting values for the MCML algorithm iterations. 
If this is not specified then the parameter values stored in the linked mean function object will be used.}

\item{se.method}{One of either `'lik'`, `'approx'`, `'perm'`, or `'none'`, see Details.}

\item{method}{The MCML algorithm to use, either `mcem` or `mcnr`, see Details. Default is `mcem`.}

\item{permutation.par}{Optional. Integer specifing the index of the parameter if permutation tests are being used.}

\item{verbose}{Logical indicating whether to provide detailed output, defaults to TRUE.}

\item{tol}{Numeric value, tolerance of the MCML algorithm, the maximum difference in parameter estimates 
between iterations at which to stop the algorithm.}

\item{m}{Integer. The number of MCMC draws of the random effects on each iteration.}

\item{max.iter}{Integer. The maximum number of iterations of the MCML algorithm.}

\item{options}{An optional list providing options to the algorithm, see Details.}
}
\value{
A `mcml` object
}
\description{
Markov Chain Monte Carlo Maximum Likelihood  model fitting
}
\details{
**MCMCML**
Fits generalised linear mixed models using one of three algorithms: Markov Chain Newton
Raphson (MCNR), Markov Chain Expectation Maximisation (MCEM), or Maximum simulated
likelihood (MSL). All the algorithms are described by McCullagh (1997). For each iteration
of the algorithm the unobserved random effect terms (\eqn{\gamma}) are simulated
using Markov Chain Monte Carlo (MCMC) methods (we use Hamiltonian Monte Carlo through Stan),
and then these values are conditioned on in the subsequent steps to estimate the covariance
parameters and the mean function parameters (\eqn{\beta}). For all the algorithms, 
the covariance parameter estimates are updated using an expectation maximisation step.
For the mean function parameters you can either use a Newton Raphson step (MCNR) or
an expectation maximisation step (MCEM). A simulated likelihood step can be added at the 
end of either MCNR or MCEM, which uses an importance sampling technique to refine the 
parameter estimates. 

The accuracy of the algorithm depends on the user specified tolerance. For higher levels of
tolerance, larger numbers of MCMC samples are likely need to sufficiently reduce Monte Carlo error.

The function also offers different methods of obtaining standard errors. First, one can generate
estimates from the estimated Hessian matrix (`se.method = 'lik'`). Second, there are robust standard 
errors using a sandwich estimator based on White (1982) (`se.method = 'robust'`). 
Third, there are use approximate generalised least squares estimates based on the maximum likelihood 
estimates of the covariance
parameters (`se.method = 'approx'`), or use a permutation test approach (`se.method = 'perm'`).
Note that the permutation test can be accessed separately with the function `permutation_test()`.

There are several options that can be specified to the function using the `options` argument. 
The options should be provided as a list, e.g. `options = list(method="mcnr")`. The possible options are:
* `b_se_only` TRUE (calculate standard errors of the mean function parameters only) or FALSE (calculate
all standard errors), default it FALSE.
* `use_cmdstanr` TRUE (uses `cmdstanr` for the MCMC sampling, requires cmdstanr), or FALSE (uses `rstan`). Default is FALSE.
* `skip_cov_optim` TRUE (skips the covariance parameter estimation step, and uses the values covariance$parameters), or 
FALSE (run the whole algorithm)], default is FALSE
* `sim_lik_step` TRUE (conduct a simulated likelihood step at the end of the algorithm), or FALSE (does
not do this step), defaults to FALSE.
* `no_warnings` TRUE (do not report any warnings) or FALSE (report warnings), default to FALSE
* `perm_type` Either `cov` (use weighted test statistic in permutation test) or `unw` (use unweighted
test statistic), defaults to `cov`. See `permutation_test()`.
* `perm_iter` Number of iterations for the permutation test, default is 100.
* `perm_parallel` TRUE (run permuation test in parallel) or FALSE (runs on a single thread), default to TRUE
* `warmup_iter` Number of warmup iterations on each iteration for the MCMC sampler, default is 500
* `perm_ci_steps` Number of steps for the confidence interval search procedure if using the permutation
test, default is 1000. See `permutation_test()`.
* `fd_tol` The tolerance of the first difference method to estimate the Hessian and Gradient, default 
is 1e-4.
}
\examples{
\dontrun{
df <- nelder(~(cl(10)*t(5)) > ind(10))
df$int <- 0
df[df$cl > 5, 'int'] <- 1
des <- Design$new(
  covariance = list(
    data = df,
    formula = ~ (1|gr(cl)*ar1(t)),
    parameters = c(0.25,0.8)),
  mean.function = list(
    formula = ~ factor(t) + int - 1,
    data=df,
    parameters = c(rep(0,5),0.6),
    family = binomial())
)
ysim <- des$sim_data()
# fits the models using MCEM but does not estimate standard errors
fit1 <- des$MCML(y = ysim,
  se.method = "none")
#fits the models using MCNR but does not estimate standard errors
fit2 <- des$MCML(y = ysim,
  se.method = "none",
  method="mcnr")
#fits the models and uses permutation tests for parameter of interest
fit3 <- des$MCML(y = ysim,
  se.method = "perm",
  permutation.par = 6,
  options = list(
    perm_type="unw",
    perm_iter=1000,
    perm_parallel=FALSE,
    perm_ci_steps=1000
  ))
 #adds a simulated likelihood step after the MCEM algorithm
fit4 <- des$MCML(y = des$sim_data(),
  se.method = "none",
  options = list(
    sim_lik_step=TRUE
  ))  
}
}
