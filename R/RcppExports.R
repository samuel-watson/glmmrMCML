# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

dfbeta_stat <- function(sigma, X, y, par) {
    .Call(`_glmmr_dfbeta_stat`, sigma, X, y, par)
}

#' Efficiently calculate the inverse of a sub-matrix
#' 
#' Efficiently calculate the inverse of a sub-matrix
#' @details
#' For a given matrix \eqn{A = B^-1}, this will calculate the inverse of a submatrix of B 
#' given only matrix A and requiring only vector multiplication. B typically represents a 
#' covariance matrix for observations 1,...,N and the function is used to calculate the 
#' inverse covariance matrix for a subset of those observations.
#' @param A A square inverse matrix
#' @param i Vector of integers specifying the rows/columns to remove from B, see details
#' @return The inverse of a submatrix of B
#' @examples
#' B <- matrix(runif(16),nrow=4,ncol=4)
#' diag(B) <- diag(B)+1
#' A <- solve(B)
#' remove_one_many_mat(A,1)
#' #equal to
#' solve(B[2:4,2:4])
remove_one_many_mat <- function(A, i) {
    .Call(`_glmmr_remove_one_many_mat`, A, i)
}

#' Efficiently calculates the inverse of a super-matrix 
#' 
#' Efficiently calculates the inverse of a super-matrix by adding an observation
#' @details
#' Given matrix \eqn{A = B^-1} where B is a submatrix of a matrix C, this function efficiently calculates
#' the inverse the matrix B+, which is B adding another row/column from C. For example, if C
#' is the covariance matrix of observations 1,...,N, and B the covariance matrix of observations
#' 1,...,n where n<N, then this function will calculate the inverse of the covariance matrix of 
#' the observations 1,...,n+1.
#' @param A Inverse matrix of dimensions `n`
#' @param sigma_jj The element of C corresponding to the element [j,j] in matrix C where j is the index
#' of the row/column we want to add, see Details
#' @param f A vector of dimension n x 1, corresponding to the elements [b,j] in C where b is the indexes
#' that make up submatrix B
#' @return A matrix of size dim(A)+1
#' @examples
#' B <- matrix(runif(16),nrow=4,ncol=4)
#' diag(B) <- diag(B)+1
#' A <- solve(B[2:4,2:4])
#' add_one_mat(A,B[1,1],B[2:4,1])
#' #equal to
#' solve(B)
add_one_mat <- function(A, sigma_jj, f) {
    .Call(`_glmmr_add_one_mat`, A, sigma_jj, f)
}

#' Hill-Climbing algorithm to identify optimal GLMM design
#' 
#' Hill-Climbing algorithm to identify optimal GLMM design
#' @param N Integer specifying number of experimental conditions in the optimal design
#' @param idx_in Integer vector specifying the indexes of the experimental conditions to start from
#' @param n Integer specifying the size of the design to find. For local search, this should be equal to the size of idx_in
#' @param C_list List of C vectors for the c-optimal function, see \link{glmmr}[DesignSpace]
#' @param X_list List of X matrices
#' @param sig_list List of inverse covariance matrices
#' @param weights Vector specifying the weights of each design
#' @param exp_cond Vector specifying the experimental condition index of each observation
#' @param nfix Vector listing the experimental condition indexes that are fixed in the design
#' @param any_fix Integer. 0 = no experimental conditions are fixed, 1 = some experimental conditions are fixed
#' @param type Integer. 0 = local search algorith. 1 = greedy search algorithm.
#' @param rd_mode Integer. Robust objective function, 1=weighted average, 2=minimax
#' @param trace Logical indicating whether to provide detailed output
#' @return A vector of experimental condition indexes in the optimal design
GradRobustStep <- function(idx_in, n, C_list, X_list, Z_list, D_list, w_diag, max_obs, weights, exp_cond, nfix, V0_list, any_fix = 0L, type = 0L, rd_mode = 1L, trace = TRUE, uncorr = FALSE, bayes = FALSE) {
    .Call(`_glmmr_GradRobustStep`, idx_in, n, C_list, X_list, Z_list, D_list, w_diag, max_obs, weights, exp_cond, nfix, V0_list, any_fix, type, rd_mode, trace, uncorr, bayes)
}

#' Log multivariate Gaussian probability density funciton
#' 
#' Log multivariate Gaussian probability density funciton
#' @param u Vector of realisations from the distribution
#' @param D Inverse covariance matrix
#' @param logdetD Log determinant of the covariance matrix
log_mv_gaussian_pdf <- function(u, D, logdetD) {
    .Call(`_glmmr_log_mv_gaussian_pdf`, u, D, logdetD)
}

#' Exponential covariance function
#' 
#' Exponential covariance function
#' @details
#' \deqn{\theta_1 exp(-x/\theta_2)}
#' @param x Numeric value 
#' @param par1 First parameter of the distribution
fexp <- function(x, par1) {
    .Call(`_glmmr_fexp`, x, par1)
}

#' Squared exponential covariance function
#' 
#' Squared exponential covariance function
#' @details
#' \deqn{\theta_1 exp(-x^2/\theta_2^2)}
#' @param x Numeric value 
#' @param par1 First parameter of the distribution
#' @param par2 Second parameter of the distribution
sqexp <- function(x, par1, par2) {
    .Call(`_glmmr_sqexp`, x, par1, par2)
}

#' Matern covariance function
#' 
#' Matern covariance function
#' @details
#' TBC
#' @param x Numeric value 
#' @param rho First parameter of the distribution
#' @param nu Second parameter of the distribution
matern <- function(x, rho, nu) {
    .Call(`_glmmr_matern`, x, rho, nu)
}

#' Bessel covariance function
#' 
#' Bessel covariance function
#' @details
#' TBC
#' @param x Numeric value 
#' @param rho First parameter of the distribution
bessel1 <- function(x, rho) {
    .Call(`_glmmr_bessel1`, x, rho)
}

#' Generates a block of the random effects covariance matrix
#' 
#' Generates a block of the random effects covariance matrix
#' @details 
#' Using the sparse representation of the random effects covariance matrix, constructs
#' one of the blocks. The function definitions are: 1 indicator, 2 exponential,
#' 3 AR-1, 4 squared exponential, 5 matern, 6 Bessel.
#' @param N_dim Integer specifying the dimension of the matrix
#' @param N_func Integer specifying the number of functions in the covariance function 
#' for this block.
#' @param func_def Vector of integers of same length as `func_def` specifying the function definition for each function. 
#' @param N_var_func Vector of integers of same length as `func_def` specying the number 
#' of variables in the argument to the function
#' @param col_id Matrix of integers of dimension length(func_def) x max(N_var_func) that indicates
#' the respective column indexes of `cov_data` 
#' @param N_par Vector of integers of same length as `func_def` specifying the number
#' of parameters in the function
#' @param cov_data Matrix holding the data for the covariance matrix
#' @param gamma Vector of covariance parameters specified in order they appear in the functions 
#' specified by `func_def`
#' @return A symmetric positive definite matrix
genBlockD <- function(N_dim, N_func, func_def, N_var_func, col_id, N_par, cov_data, gamma) {
    .Call(`_glmmr_genBlockD`, N_dim, N_func, func_def, N_var_func, col_id, N_par, cov_data, gamma)
}

#' Generates the covariance matrix of the random effects
#' 
#' Generates the covariance matrix of the random effects from a sparse representation
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param gamma Vector of covariance parameters specified in order they appear column wise in the functions 
#' specified by `func_def`
#' @return A symmetric positive definite covariance matrix
genD <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, gamma) {
    .Call(`_glmmr_genD`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, gamma)
}

#' Approximation to the log factorial
#' 
#' Ramanujan's approximation to the log factorial
#' @param n Integer to calculate log(n!)
#' @return A numeric value
log_factorial_approx <- function(n) {
    .Call(`_glmmr_log_factorial_approx`, n)
}

gen_dhdmu <- function(xb, family, link) {
    .Call(`_glmmr_gen_dhdmu`, xb, family, link)
}

#' Optimises the log-likelihood of the random effects
#' 
#' Optimises the log-likelihood of the random effects
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param start Vector of starting values for the optmisation
#' @param lower Vector of lower bounds for the covariance parameters
#' @param upper Vector of upper bounds for the covariance parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of covariance parameters that maximise the log likelihood
d_lik_optim <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, u, start, lower, upper, trace = 0L) {
    .Call(`_glmmr_d_lik_optim`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, u, start, lower, upper, trace)
}

#' Optimises the log-likelihood of the observations conditional on the random effects
#' 
#' Optimises the log-likelihood of the observations conditional on the random effects
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of parameters that maximise the log likelihood
l_lik_optim <- function(Z, X, y, u, family, link, start, lower, upper, trace) {
    .Call(`_glmmr_l_lik_optim`, Z, X, y, u, family, link, start, lower, upper, trace)
}

#' Optimises the log-likelihood of the observations conditional on the random effects
#' 
#' Optimises the log-likelihood of the observations conditional on the random effects
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of parameters that maximise the log likelihood
l_lik_hess <- function(Z, X, y, u, family, link, start, lower, upper, trace, tol = 1e-4) {
    .Call(`_glmmr_l_lik_hess`, Z, X, y, u, family, link, start, lower, upper, trace, tol)
}

#' Calculates the gradient of the full log-likelihood 
#' 
#' Calculates the gradient of the full log-likelihood 
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param cov_par_fix A vector of covariance parameters for importance sampling
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of the gradient for each parameter
f_lik_grad <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol = 1e-4, importance = FALSE) {
    .Call(`_glmmr_f_lik_grad`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol, importance)
}

#' Calculates the Hessian of the full log-likelihood 
#' 
#' Calculates the Hessian of the full log-likelihood 
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param cov_par_fix A vector of covariance parameters for importance sampling
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A matrix of the Hessian for each parameter
f_lik_hess <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol = 1e-4, importance = FALSE) {
    .Call(`_glmmr_f_lik_hess`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol, importance)
}

#' Simulated likelihood maximisation for the GLMM 
#' 
#' Simulated likelihood maximisation for the GLMM
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param cov_par_fix A vector of covariance parameters for importance sampling
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of the parameters that maximise the simulated likelihood
f_lik_optim <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, trace) {
    .Call(`_glmmr_f_lik_optim`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, trace)
}

#' Newton-Raphson step for the MCMCML algorithm 
#' 
#' Newton-Raphson step for the MCMCML algorithm
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param beta A vector specifying the current values of the mean function parameters
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @return A vector specifying the Newton-Raphson step for the parameters
mcnr_step <- function(y, X, Z, beta, u, family, link) {
    .Call(`_glmmr_mcnr_step`, y, X, Z, beta, u, family, link)
}

#' Calculates the Akaike Information Criterion for the GLMM
#' 
#' Calculates the Akaike Information Criterion for the GLMM 
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param beta_par Vector specifying the values of the mean function parameters
#' @param cov_par Vector specifying the values of the covariance parameters
#' @return A matrix of the Hessian for each parameter
aic_mcml <- function(Z, X, y, u, family, link, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, beta_par, cov_par) {
    .Call(`_glmmr_aic_mcml`, Z, X, y, u, family, link, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, beta_par, cov_par)
}

#' Combines a field of matrices into a block diagonal matrix
#' 
#' Combines a field of matrices into a block diagonal matrix. Used on
#' the output of `genD`
#' @param matfield A field of matrices
#' @return A block diagonal matrix
blockMat <- function(matfield) {
    .Call(`_glmmr_blockMat`, matfield)
}

fast_glm_impl <- function(Xs, ys, weightss, offsets, starts, mus, etas, var, mu_eta, linkinv, dev_resids, valideta, validmu, type, tol, maxit) {
    .Call(`_glmmr_fast_glm_impl`, Xs, ys, weightss, offsets, starts, mus, etas, var, mu_eta, linkinv, dev_resids, valideta, validmu, type, tol, maxit)
}

#' Simplified version of fastglm's `fastglm` function
#' 
#' Fast generalized model fitting with a simplified version of fastglm's `fastglm` function
#' @details
#' This is a simplified wrapper to the `fastglm` function in the fastglm package, please access that package for more details.
#' @param Xs input model matrix. Must be a matrix object
#' @param y numeric response vector
#' @param weightss an optional vector of 'prior weights' to be used in the fitting process. Should be a numeric vector.
#' @param offsets this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be a numeric vector of length equal to the number of cases
#' @param A \link{stats}[family] object. See `fastglm` for details
#' @return A list with the elements:
#' * `coefficients` a vector of coefficients
#' * `se` a vector of the standard errors of the coefficient estimates
#' * `rank` a scalar denoting the computed rank of the model matrix
#' * `df.residual` a scalar denoting the degrees of freedom in the model
#' * `residuals` a vector of residuals
#' * `s` a numeric scalar - the root mean square for residuals
#' * `fitted.values` the fitted values
myglm <- function(Xs, ys, weightss, offsets, family) {
    .Call(`_glmmr_myglm`, Xs, ys, weightss, offsets, family)
}

#' The quasi-score statistic for a generalised linear mixed model
#' 
#' Generates the quasi-score statistic for a generalised linear mixed model
#' 
#' @param resids A numeric vector of generalised residuals
#' @param tr A numeric vector of 1s (treatment group) and -1s (control group)
#' @param xb A numeric vector of fitted linear predictors
#' @param invS A matrix. If using the weighted statistic then it should be the inverse covariance matrix of the observations
#' @param family2 A string naming the link function
#' @param weight Logical value indicating whether to use the weighted statistic (TRUE) or the unweighted statistic (FALSE)
#' @return A scalar value with the value of the statistic
qscore_impl <- function(resids, tr, xb, invS, family2, weight = TRUE) {
    .Call(`_glmmr_qscore_impl`, resids, tr, xb, invS, family2, weight)
}

#' Generates realisations of the permutational test statistic distribution 
#' 
#' Generates realisations of the permutational test statistic distribution from a given matrix of permutations
#' 
#' @param resids A numeric vector of generalised residuals
#' @param tr_mat A matrix. Each column is a new random treatment allocation with 1s (treatment group) and 0s (control group)
#' @param xb A numeric vector of fitted linear predictors
#' @param invS A matrix. If using the weighted statistic then it should be the inverse covariance matrix of the observations
#' @param family2 A string naming the link function
#' @param weight Logical value indicating whether to use the weighted statistic (TRUE) or the unweighted statistic (FALSE)
#' @param verbose Logical indicating whether to report detailed output
#' @return A numeric vector of quasi-score test statistics for each of the permutations
permutation_test_impl <- function(resids, tr_mat, xb, invS, family2, weight, iter = 1000L, verbose = TRUE) {
    .Call(`_glmmr_permutation_test_impl`, resids, tr_mat, xb, invS, family2, weight, iter, verbose)
}

#' Confidence interval search procedure
#' 
#' Search for the bound of a confidence interval using permutation test statistics
#' 
#' @param start Numeric value indicating the starting value for the search procedure
#' @param b Numeric value indicating the parameter estimate
#' @param Xnull_ Numeric matrix. The covariate design matrix with the treatment variable removed
#' @param y_ Numeric vector of response variables
#' @param tr_ Numeric vector. The original random allocation (0s and 1s)
#' @param new_tr_mat A matrix. Each column is a new random treatment allocation with 1s (treatment group) and 0s (control group)
#' @param xb A numeric vector of fitted linear predictors
#' @param invS A matrix. If using the weighted statistic then it should be the inverse covariance matrix of the observations
#' @param family A \link{stats}[family] object
#' @param family2 A string naming the link function
#' @param nsteps Integer specifying the number of steps of the search procedure
#' @param weight Logical indicating whether to use the weighted (TRUE) or unweighted (FALSE) test statistic
#' @param alpha The function generates (1-alpha)*100% confidence intervals. Default is 0.05.
#' @param verbose Logical indicating whether to provide detailed output.
#' @return The estimated confidence interval bound
confint_search <- function(start, b, Xnull_, y_, tr_, new_tr_mat, xb, invS, family, family2, nsteps = 1000L, weight = TRUE, alpha = 0.05, verbose = TRUE) {
    .Call(`_glmmr_confint_search`, start, b, Xnull_, y_, tr_, new_tr_mat, xb, invS, family, family2, nsteps, weight, alpha, verbose)
}

