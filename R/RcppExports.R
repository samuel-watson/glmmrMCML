# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximation to the log factorial
#' 
#' Ramanujan's approximation to the log factorial
#' @param n Integer to calculate log(n!)
#' @return A numeric value
log_factorial_approx <- function(n) {
    .Call(`_glmmrMCML_log_factorial_approx`, n)
}

#' Optimises the log-likelihood of the random effects
#' 
#' Optimises the log-likelihood of the random effects
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param start Vector of starting values for the optmisation
#' @param lower Vector of lower bounds for the covariance parameters
#' @param upper Vector of upper bounds for the covariance parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of covariance parameters that maximise the log likelihood
d_lik_optim <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, u, start, lower, upper, trace = 0L) {
    .Call(`_glmmrMCML_d_lik_optim`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, u, start, lower, upper, trace)
}

#' Optimises the log-likelihood of the observations conditional on the random effects
#' 
#' Optimises the log-likelihood of the observations conditional on the random effects
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of parameters that maximise the log likelihood
l_lik_optim <- function(Z, X, y, u, family, link, start, lower, upper, trace) {
    .Call(`_glmmrMCML_l_lik_optim`, Z, X, y, u, family, link, start, lower, upper, trace)
}

#' Optimises the log-likelihood of the observations conditional on the random effects
#' 
#' Optimises the log-likelihood of the observations conditional on the random effects
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of parameters that maximise the log likelihood
l_lik_hess <- function(Z, X, y, u, family, link, start, lower, upper, trace, tol = 1e-4) {
    .Call(`_glmmrMCML_l_lik_hess`, Z, X, y, u, family, link, start, lower, upper, trace, tol)
}

#' Calculates the gradient of the full log-likelihood 
#' 
#' Calculates the gradient of the full log-likelihood 
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param cov_par_fix A vector of covariance parameters for importance sampling
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of the gradient for each parameter
f_lik_grad <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol = 1e-4, importance = FALSE) {
    .Call(`_glmmrMCML_f_lik_grad`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol, importance)
}

#' Calculates the Hessian of the full log-likelihood 
#' 
#' Calculates the Hessian of the full log-likelihood 
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param cov_par_fix A vector of covariance parameters for importance sampling
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A matrix of the Hessian for each parameter
f_lik_hess <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol = 1e-4, importance = FALSE) {
    .Call(`_glmmrMCML_f_lik_hess`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, tol, importance)
}

#' Simulated likelihood maximisation for the GLMM 
#' 
#' Simulated likelihood maximisation for the GLMM
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param cov_par_fix A vector of covariance parameters for importance sampling
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param start Vector of starting values for the optimisation
#' @param lower Vector of lower bounds for the model parameters
#' @param upper Vector of upper bounds for the model parameters
#' @param trace Integer indicating what to report to the console, 0= nothing, 1-3=detailed output
#' @return A vector of the parameters that maximise the simulated likelihood
f_lik_optim <- function(B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, trace) {
    .Call(`_glmmrMCML_f_lik_optim`, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, Z, X, y, u, cov_par_fix, family, link, start, lower, upper, trace)
}

#' Newton-Raphson step for the MCMCML algorithm 
#' 
#' Newton-Raphson step for the MCMCML algorithm
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param beta A vector specifying the current values of the mean function parameters
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @return A vector specifying the Newton-Raphson step for the parameters
mcnr_step <- function(y, X, Z, beta, u, family, link) {
    .Call(`_glmmrMCML_mcnr_step`, y, X, Z, beta, u, family, link)
}

#' Calculates the Akaike Information Criterion for the GLMM
#' 
#' Calculates the Akaike Information Criterion for the GLMM 
#' @param Z Matrix Z of the GLMM
#' @param X Matrix X of the GLMM
#' @param y Vector of observations
#' @param u Matrix of samples of the random effects. Each column is a sample.
#' @param family Character specifying the family
#' @param link Character specifying the link function
#' @param B Integer specifying the number of blocks in the matrix
#' @param N_dim Vector of integers, which each value specifying the dimension of each block
#' @param N_func Vector of integers specifying the number of functions in the covariance function 
#' for each block.
#' @param func_def Matrix of integers where each column specifies the function definition for each function in each block. 
#' @param N_var_func Matrix of integers of same size as `func_def` with each column specying the number 
#' of variables in the argument to each function in each block
#' @param col_id 3D array (cube) of integers of dimension length(func_def) x max(N_var_func) x B 
#' where each slice the respective column indexes of `cov_data` for each function in the block
#' @param N_par Matrix of integers of same size as `func_def` with each column specifying the number
#' of parameters in the function in each block
#' @param cov_data 3D array (cube) holding the data for the covariance matrix where each of the B slices
#' is the data required for each block
#' @param beta_par Vector specifying the values of the mean function parameters
#' @param cov_par Vector specifying the values of the covariance parameters
#' @return A matrix of the Hessian for each parameter
aic_mcml <- function(Z, X, y, u, family, link, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, beta_par, cov_par) {
    .Call(`_glmmrMCML_aic_mcml`, Z, X, y, u, family, link, B, N_dim, N_func, func_def, N_var_func, col_id, N_par, sum_N_par, cov_data, beta_par, cov_par)
}

fast_glm_impl <- function(Xs, ys, weightss, offsets, starts, mus, etas, var, mu_eta, linkinv, dev_resids, valideta, validmu, type, tol, maxit) {
    .Call(`_glmmrMCML_fast_glm_impl`, Xs, ys, weightss, offsets, starts, mus, etas, var, mu_eta, linkinv, dev_resids, valideta, validmu, type, tol, maxit)
}

#' Simplified version of fastglm's `fastglm` function
#' 
#' Fast generalized model fitting with a simplified version of fastglm's `fastglm` function
#' @details
#' This is a simplified wrapper to the `fastglm` function in the fastglm package, please access that package for more details.
#' @param Xs input model matrix. Must be a matrix object
#' @param y numeric response vector
#' @param weightss an optional vector of 'prior weights' to be used in the fitting process. Should be a numeric vector.
#' @param offsets this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be a numeric vector of length equal to the number of cases
#' @param A \link{stats}[family] object. See `fastglm` for details
#' @return A list with the elements:
#' * `coefficients` a vector of coefficients
#' * `se` a vector of the standard errors of the coefficient estimates
#' * `rank` a scalar denoting the computed rank of the model matrix
#' * `df.residual` a scalar denoting the degrees of freedom in the model
#' * `residuals` a vector of residuals
#' * `s` a numeric scalar - the root mean square for residuals
#' * `fitted.values` the fitted values
myglm <- function(Xs, ys, weightss, offsets, family) {
    .Call(`_glmmrMCML_myglm`, Xs, ys, weightss, offsets, family)
}

#' The quasi-score statistic for a generalised linear mixed model
#' 
#' Generates the quasi-score statistic for a generalised linear mixed model
#' 
#' @param resids A numeric vector of generalised residuals
#' @param tr A numeric vector of 1s (treatment group) and -1s (control group)
#' @param xb A numeric vector of fitted linear predictors
#' @param invS A matrix. If using the weighted statistic then it should be the inverse covariance matrix of the observations
#' @param family2 A string naming the link function
#' @param weight Logical value indicating whether to use the weighted statistic (TRUE) or the unweighted statistic (FALSE)
#' @return A scalar value with the value of the statistic
qscore_impl <- function(resids, tr, xb, invS, family2, weight = TRUE) {
    .Call(`_glmmrMCML_qscore_impl`, resids, tr, xb, invS, family2, weight)
}

#' Generates realisations of the permutational test statistic distribution 
#' 
#' Generates realisations of the permutational test statistic distribution from a given matrix of permutations
#' 
#' @param resids A numeric vector of generalised residuals
#' @param tr_mat A matrix. Each column is a new random treatment allocation with 1s (treatment group) and 0s (control group)
#' @param xb A numeric vector of fitted linear predictors
#' @param invS A matrix. If using the weighted statistic then it should be the inverse covariance matrix of the observations
#' @param family2 A string naming the link function
#' @param weight Logical value indicating whether to use the weighted statistic (TRUE) or the unweighted statistic (FALSE)
#' @param verbose Logical indicating whether to report detailed output
#' @return A numeric vector of quasi-score test statistics for each of the permutations
permutation_test_impl <- function(resids, tr_mat, xb, invS, family2, weight, iter = 1000L, verbose = TRUE) {
    .Call(`_glmmrMCML_permutation_test_impl`, resids, tr_mat, xb, invS, family2, weight, iter, verbose)
}

#' Confidence interval search procedure
#' 
#' Search for the bound of a confidence interval using permutation test statistics
#' 
#' @param start Numeric value indicating the starting value for the search procedure
#' @param b Numeric value indicating the parameter estimate
#' @param Xnull_ Numeric matrix. The covariate design matrix with the treatment variable removed
#' @param y_ Numeric vector of response variables
#' @param tr_ Numeric vector. The original random allocation (0s and 1s)
#' @param new_tr_mat A matrix. Each column is a new random treatment allocation with 1s (treatment group) and 0s (control group)
#' @param xb A numeric vector of fitted linear predictors
#' @param invS A matrix. If using the weighted statistic then it should be the inverse covariance matrix of the observations
#' @param family A \link{stats}[family] object
#' @param family2 A string naming the link function
#' @param nsteps Integer specifying the number of steps of the search procedure
#' @param weight Logical indicating whether to use the weighted (TRUE) or unweighted (FALSE) test statistic
#' @param alpha The function generates (1-alpha)*100% confidence intervals. Default is 0.05.
#' @param verbose Logical indicating whether to provide detailed output.
#' @return The estimated confidence interval bound
confint_search <- function(start, b, Xnull_, y_, tr_, new_tr_mat, xb, invS, family, family2, nsteps = 1000L, weight = TRUE, alpha = 0.05, verbose = TRUE) {
    .Call(`_glmmrMCML_confint_search`, start, b, Xnull_, y_, tr_, new_tr_mat, xb, invS, family, family2, nsteps, weight, alpha, verbose)
}

